#
# Copyright The NOMAD Authors.
#
# This file is part of NOMAD. See https://nomad-lab.eu for further info.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

from datetime import datetime
from typing import TYPE_CHECKING

import numpy as np
import pandas as pd
import plotly.express as px
from nomad.datamodel.data import ArchiveSection, EntryData
from nomad.datamodel.metainfo.basesections import (
    Activity,
    CompositeSystem,
    Experiment,
    ExperimentStep,
    Process,
    ProcessStep,
    PublicationReference,
)
from nomad.datamodel.metainfo.plot import PlotlyFigure, PlotSection
from nomad.metainfo import Datetime, Package, Quantity, Section, SubSection
from plotly.subplots import make_subplots

if TYPE_CHECKING:
    from nomad.datamodel.datamodel import EntryArchive
    from structlog.stdlib import BoundLogger

m_package = Package(name='Crystallization')


class Solution(CompositeSystem, EntryData, ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        """
        The normalizer for the `Solution` class.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """
        super().normalize(archive, logger)


class Solutions(ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    precursor = Quantity(
        type=Solution,
        a_eln={'component': 'ReferenceEditQuantity'},
    )


class CaPActivity(Activity, ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        """
        The normalizer for the `CaPActivity` class.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """
        super().normalize(archive, logger)


class CaPSteps(ExperimentStep, ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    activity = Quantity(
        type=CaPActivity,
        a_eln={'component': 'ReferenceEditQuantity'},
    )

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        """
        The normalizer for the `CaPSteps` class.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """
        super().normalize(archive, logger)


class CaP_sample(CompositeSystem, EntryData, ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        """
        The normalizer for the `CaP_sample` class.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """
        super().normalize(archive, logger)


class SolutionPreparation(Process, CaPActivity, EntryData, ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        """
        The normalizer for the `SolutionPreparation` class.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """
        super().normalize(archive, logger)


class ProgramSteps(ProcessStep, ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        """
        The normalizer for the `ProgramSteps` class.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """
        super().normalize(archive, logger)


class AddingSolution(ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    reference = Quantity(
        type=Solution,
        description=' ',
        a_eln={'component': 'ReferenceEditQuantity', 'label': 'Solution'},
    )
    amount_of_solution = Quantity(
        type=np.float64,
        description=' ',
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'milliliter'},
        shape=[1],
        unit='milliliter',
    )
    rate = Quantity(
        type=np.float64,
        description=' ',
        a_eln={
            'component': 'NumberEditQuantity',
            'defaultDisplayUnit': 'milliliter/minute',
        },
        shape=[1],
        unit='milliliter/minute',
    )


class ReactorProgramStep(ProgramSteps, ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    stirring_ration_speed = Quantity(
        type=np.float64,
        description=' ',
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': '1/minute'},
        shape=[1],
        unit='1/minute',
    )
    temperature_setpoint = Quantity(
        type=np.float64,
        description=' ',
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': '\u00b0C'},
        shape=[1],
        unit='\u00b0C',
    )
    heating_rate = Quantity(
        type=np.float64,
        description=' ',
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'K/minute'},
        shape=[1],
        unit='K/minute',
    )
    AddingSolution = SubSection(
        section_def=AddingSolution,
        base_sections=['CompositeSystemReference'],
        repeats=True,
    )

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        """
        The normalizer for the `ReactorProgramStep` class.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """
        super().normalize(archive, logger)


class ReactorDataLog(ArchiveSection):
    m_def = Section()
    local_time = Quantity(
        type=Datetime,
        shape=['*'],
        description='date and time of the log entry',
        # a_eln={'component': 'DateTimeEditQuantity'},
    )
    elapsed_time = Quantity(
        type=np.float64,
        unit='second',
        shape=['*'],
        description='elapsed time since start of the experiment',
    )
    total_volume = Quantity(
        type=np.float64,
        shape=['*'],
        description='total volume of Ca(NO3)2 Ce(NO3)3 in the reactor',
        unit='milliliter',
    )
    conductivity = Quantity(
        type=np.float64,
        shape=['*'],
        description='conductivity of the solution in the reactor',
        unit='milliseconds/centimeter',
    )
    ph_pressure = Quantity(
        type=np.float64,
        shape=['*'],
        description='pH pressure of the solution in the reactor',
    )
    temperature = Quantity(
        type=np.float64,
        shape=['*'],
        description='temperature of the solution in the reactor',
        unit='\u00b0C',
    )


class ReactorProgram(Process, CaPActivity, PlotSection, EntryData, ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    data_file = Quantity(
        type=str,
        description="""
        A reference to an uploaded .csv from the synthesis process.
        """,
        a_browser={'adaptor': 'RawFileAdaptor'},
        a_eln={'component': 'FileEditQuantity'},
    )
    reactordatalog = SubSection(
        section_def=ReactorDataLog,
        a_eln=None,
    )
    steps = SubSection(
        section_def=ProgramSteps,
        repeats=True,
    )

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        """
        The normalizer for the `ReactorProgram` class.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """
        super().normalize(archive, logger)
        if self.data_file is not None:
            with archive.m_context.raw_file(self.data_file) as file:
                df_datalog = pd.read_csv(
                    file,
                    header=0,
                    sep=';',
                    decimal=',',
                    skiprows=[1],
                    names=[
                        'local_time',
                        'elapsed_time',
                        'total_volume',
                        'conductivity',
                        'ph_pressure',
                        'temperature',
                    ],
                    parse_dates=[
                        'local_time',
                    ],
                )
                df_datalog['elapsed_time'] = df_datalog['elapsed_time'].apply(
                    lambda x: (
                        datetime.strptime(x, '%H:%M:%S')
                        - datetime.strptime('00:00:00', '%H:%M:%S')
                    ).total_seconds()
                )
                df_datalog['elapsed_time'] = df_datalog['elapsed_time'].astype(float)

                reactordatalog = ReactorDataLog()
                reactordatalog.local_time = df_datalog['local_time'].tolist()
                reactordatalog.elapsed_time = df_datalog['elapsed_time'].tolist()
                reactordatalog.total_volume = df_datalog['total_volume'].tolist()
                reactordatalog.conductivity = df_datalog['conductivity'].tolist()
                reactordatalog.ph_pressure = df_datalog['ph_pressure'].tolist()
                reactordatalog.temperature = df_datalog['temperature'].tolist()
                self.reactordatalog = reactordatalog

                first_line = px.scatter(
                    x=reactordatalog.elapsed_time,
                    y=reactordatalog.total_volume,
                    labels={'y': 'Total Volume'},
                )
                second_line = px.scatter(
                    x=reactordatalog.elapsed_time,
                    y=reactordatalog.temperature,
                    labels={'y': 'Temperature'},
                )
                third_line = px.scatter(
                    x=reactordatalog.elapsed_time,
                    y=reactordatalog.conductivity,
                    labels={'y': 'Conductivity'},
                )
                fourth_line = px.scatter(
                    x=reactordatalog.elapsed_time,
                    y=reactordatalog.ph_pressure,
                    labels={'y': 'pH/Pressure'},
                )
                figure1 = make_subplots(rows=1, cols=1, shared_yaxes=False)
                figure1.add_trace(first_line.data[0], row=1, col=1)
                figure1.add_trace(second_line.data[0], row=1, col=1)
                figure1.add_trace(third_line.data[0], row=1, col=1)
                figure1.add_trace(fourth_line.data[0], row=1, col=1)
                # figure1.update_layout(
                #    height=400, width=716, title_text='CaP Synthesis Data'
                # )

                figure1.update_layout(
                    height=600,
                    width=900,
                    title_text='CaP Synthesis Data',
                    yaxis=dict(
                        title='Total Volume',
                        titlefont=dict(color='blue'),
                        tickfont=dict(color='blue'),
                    ),
                    yaxis2=dict(
                        title='Temperature',
                        titlefont=dict(color='red'),
                        tickfont=dict(color='red'),
                        overlaying='y',
                        side='right',
                    ),
                    yaxis3=dict(
                        title='Conductivity',
                        titlefont=dict(color='green'),
                        tickfont=dict(color='green'),
                        anchor='free',
                        overlaying='y',
                        side='left',
                        position=0.15,
                    ),
                    yaxis4=dict(
                        title='pH/Pressure',
                        titlefont=dict(color='purple'),
                        tickfont=dict(color='purple'),
                        anchor='free',
                        overlaying='y',
                        side='right',
                        position=0.85,
                    ),
                    legend=dict(
                        x=1,
                        y=1,
                        traceorder='normal',
                        font=dict(family='sans-serif', size=12, color='black'),
                        bgcolor='LightSteelBlue',
                        bordercolor='Black',
                        borderwidth=2,
                    ),
                )

                # Update each trace to correspond to its respective y-axis
                figure1.data[0].update(marker=dict(color='blue'))
                figure1.data[1].update(yaxis='y2', marker=dict(color='red'))
                figure1.data[2].update(yaxis='y3', marker=dict(color='green'))
                figure1.data[3].update(yaxis='y4', marker=dict(color='purple'))

                self.figures.append(
                    PlotlyFigure(label='figure 1', figure=figure1.to_plotly_json())
                )


class CaP_Experiment(Experiment, EntryData, ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    Based_on_Experiment = Quantity(
        type=str,  # CaP_Experiment,
        description='the experiment this experiment is based on',
        a_eln={'component': 'StringEditQuantity'},  # 'ReferenceEditQuantity'},
    )
    Difference_to_previous_experiment = Quantity(
        type=str,
        description='differences to previous experiment',
        a_eln={'component': 'StringEditQuantity'},
        shape=['*'],
    )
    Based_on_publication = SubSection(
        section_def=PublicationReference,
        a_eln=None,
    )
    steps = SubSection(
        section_def=CaPSteps,
        repeats=True,
    )
    solutions = SubSection(
        section_def=Solutions,
        repeats=True,
    )

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        """
        The normalizer for the `CaP_Experiment` class.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """
        super().normalize(archive, logger)


# class Excitation(ArchiveSection):
#     '''
#     Class autogenerated from yaml schema.
#     '''
#     m_def = Section()
#     Wavelenght = Quantity(
#         type=np.float64,
#         description=' ',
#         a_eln={
#             "component": "NumberEditQuantity",
#             "defaultDisplayUnit": "nanometer"
#         },
#         shape=[1],
#         unit="nanometer",
#     )
#     Slit = Quantity(
#         type=np.float64,
#         description=' ',
#         a_eln={
#             "component": "NumberEditQuantity",
#             "defaultDisplayUnit": "nanometer"
#         },
#         shape=[1],
#         unit="nanometer",
#     )


# class Emission(ArchiveSection):
#     '''
#     Class autogenerated from yaml schema.
#     '''
#     m_def = Section()
#     Detector = Quantity(
#         type=str,
#         description=' ',
#         a_eln={
#             "component": "StringEditQuantity"
#         },
#     )
#     Integration_time = Quantity(
#         type=np.float64,
#         description=' ',
#         a_eln={
#             "component": "NumberEditQuantity",
#             "defaultDisplayUnit": "second"
#         },
#         shape=[1],
#         unit="second",
#     )
#     DetectorSlit = Quantity(
#         type=np.float64,
#         description=' ',
#         a_eln={
#             "component": "NumberEditQuantity",
#             "defaultDisplayUnit": "nanometer"
#         },
#         shape=[1],
#         unit="nanometer",
#     )
#     GratingLines = Quantity(
#         type=np.float64,
#         description=' ',
#         a_eln={
#             "component": "NumberEditQuantity"
#         },
#         shape=[1],
#     )
#     GratingCenter = Quantity(
#         type=np.float64,
#         description=' ',
#         a_eln={
#             "component": "NumberEditQuantity",
#             "defaultDisplayUnit": "nanometer"
#         },
#         shape=[1],
#         unit="nanometer",
#     )
#     UnknownSetting = Quantity(
#         type=str,
#         description=' ',
#         a_eln={
#             "component": "StringEditQuantity"
#         },
#     )
#     Cycles = Quantity(
#         type=np.float64,
#         description=' ',
#         a_eln={
#             "component": "NumberEditQuantity"
#         },
#         shape=[1],
#     )
#     Delay = Quantity(
#         type=np.float64,
#         description=' ',
#         a_eln={
#             "component": "NumberEditQuantity",
#             "defaultDisplayUnit": "second"
#         },
#         shape=[1],
#         unit="second",
#     )
#     Dark_offset = Quantity(
#         type=str,
#         description=' ',
#         a_eln={
#             "component": "StringEditQuantity"
#         },
#     )


# class MeasurementSettings(ArchiveSection):
#     '''
#     Class autogenerated from yaml schema.
#     '''
#     m_def = Section()
#     excitation = SubSection(
#         section_def=Excitation,
#     )
#     emission = SubSection(
#         section_def=Emission,
#     )


# class LuminescenceMeasurements(Measurement, CaPActivity, EntryData, ArchiveSection):
#     '''
#     Class autogenerated from yaml schema.
#     '''
#     m_def = Section()
#     Filter = Quantity(
#         type=np.float64,
#         description='optical filter',
#         a_eln={
#             "component": "NumberEditQuantity",
#             "defaultDisplayUnit": "nanometer"
#         },
#         shape=[1],
#         unit="nanometer",
#     )
#     Measurement_Option = Quantity(
#         type=MEnum(['in-situ', 'ex-situ']),
#         description='Measurement option',
#         a_eln={
#             "component": "RadioEnumEditQuantity"
#         },
#     )
#     measurement_settings = SubSection(
#         section_def=MeasurementSettings,
#     )

#     def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
#         '''
#         The normalizer for the `LuminescenceMeasurements` class.

#         Args:
#             archive (EntryArchive): The archive containing the section that is being
#             normalized.
#             logger (BoundLogger): A structlog logger.
#         '''
#         super().normalize(archive, logger)


# class Sensors(Process, CaPActivity, EntryData, ArchiveSection):
#     '''
#     Class autogenerated from yaml schema.
#     '''
#     m_def = Section()
#     List_of_sensors = Quantity(
#         type=str,
#         description=' ',
#         a_eln={
#             "component": "StringEditQuantity"
#         },
#     )
#     Sensor_setup_drawing = Quantity(
#         type=str,
#         description=' ',
#         a_eln={
#             "component": "RichTextEditQuantity"
#         },
#     )

#     def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
#         '''
#         The normalizer for the `Sensors` class.

#         Args:
#             archive (EntryArchive): The archive containing the section that is being
#             normalized.
#             logger (BoundLogger): A structlog logger.
#         '''
#         super().normalize(archive, logger)


# class SampleRemoval(Process, CaPActivity, EntryData, ArchiveSection):
#     '''
#     Class autogenerated from yaml schema.
#     '''
#     m_def = Section()
#     Sample_removal = Quantity(
#         type=bool,
#         a_eln={
#             "component": "BoolEditQuantity"
#         },
#     )
#     steps = SubSection(
#         section_def=SampleRemovalSteps,
#         repeats=True,
#     )

#     def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
#         '''
#         The normalizer for the `SampleRemoval` class.

#         Args:
#             archive (EntryArchive): The archive containing the section that is being
#             normalized.
#             logger (BoundLogger): A structlog logger.
#         '''
#         super().normalize(archive, logger)


# class SampleRemovalSteps(ProcessStep, ArchiveSection):
#     '''
#     Class autogenerated from yaml schema.
#     '''
#     m_def = Section()
#     sample_at_removal_time = Quantity(
#         type=CaP_sample,
#         description='sample that was removed from the reactor at a given time in minutes',
#         a_eln={
#             "component": "ReferenceEditQuantity"
#         },
#     )
#     duration = Quantity(
#         type=np.float64,
#         a_eln={
#             "component": "NumberEditQuantity",
#             "defaultDisplayUnit": "minute",
#             "label": "removal time in minutes"
#         },
#         unit="minute",
#     )

#     def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
#         '''
#         The normalizer for the `SampleRemovalSteps` class.

#         Args:
#             archive (EntryArchive): The archive containing the section that is being
#             normalized.
#             logger (BoundLogger): A structlog logger.
#         '''
#         super().normalize(archive, logger)


# class SampleTreatment(Process, CaPActivity, EntryData, ArchiveSection):
#     '''
#     Class autogenerated from yaml schema.
#     '''
#     m_def = Section()
#     steps = SubSection(
#         section_def=SampleTreatmentSteps,
#         repeats=True,
#     )

#     def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
#         '''
#         The normalizer for the `SampleTreatment` class.

#         Args:
#             archive (EntryArchive): The archive containing the section that is being
#             normalized.
#             logger (BoundLogger): A structlog logger.
#         '''
#         super().normalize(archive, logger)


# class SampleTreatmentSteps(ProcessStep, ArchiveSection):
#     '''
#     Class autogenerated from yaml schema.
#     '''
#     m_def = Section()

#     def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
#         '''
#         The normalizer for the `SampleTreatmentSteps` class.

#         Args:
#             archive (EntryArchive): The archive containing the section that is being
#             normalized.
#             logger (BoundLogger): A structlog logger.
#         '''
#         super().normalize(archive, logger)


# class Rest(SampleTreatmentSteps, ArchiveSection):
#     '''
#     Class autogenerated from yaml schema.
#     '''
#     m_def = Section()

#     def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
#         '''
#         The normalizer for the `Rest` class.

#         Args:
#             archive (EntryArchive): The archive containing the section that is being
#             normalized.
#             logger (BoundLogger): A structlog logger.
#         '''
#         super().normalize(archive, logger)


# class PrepareForXRD(SampleTreatmentSteps, ArchiveSection):
#     '''
#     Class autogenerated from yaml schema.
#     '''
#     m_def = Section()

#     def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
#         '''
#         The normalizer for the `PrepareForXRD` class.

#         Args:
#             archive (EntryArchive): The archive containing the section that is being
#             normalized.
#             logger (BoundLogger): A structlog logger.
#         '''
#         super().normalize(archive, logger)


# class Results(Analysis, CaPActivity, EntryData, ArchiveSection):
#     '''
#     Class autogenerated from yaml schema.
#     '''
#     m_def = Section()

#     def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
#         '''
#         The normalizer for the `Results` class.

#         Args:
#             archive (EntryArchive): The archive containing the section that is being
#             normalized.
#             logger (BoundLogger): A structlog logger.
#         '''
#         super().normalize(archive, logger)


m_package.__init_metainfo__()
